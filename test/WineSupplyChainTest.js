// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
const SupplyChain = artifacts.require('WineSupplyChain')
const BigNumber = require('bignumber.js')

contract('WineSupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    let sku = 1
    let upc = 1
    const ownerID = accounts[0]
    const originProducerID = accounts[1]
    const originProducerName = "Concha y Toro"
    const originProducerInformation = "Valle del Maipo, Chile"
    const originFarmLatitude = "-38.239770"
    const originFarmLongitude = "144.341490"
    let grapeType = 'Carmenere'
    let harvestDate = 20190505
    let harvestNotes = 'Vineyards #15-36'
    let wineLotID = 1
    let fermentationTankID = 12
    let barrelID = 1
    let numDaysAging = 90
    let bottlingDate = 20190530
    let numBottlesLot = 1000
    let numDaysResting = 120
    let wineLabel = 'Casillero del Diablo Reserva'
    let wineInformation = '13.5% alcohol by volume'
    let certification = 'DOCG'
    const price = 5000000
    let imageHash = 'HASH';
    const certifierID = accounts[2]
    const distributorID = accounts[3]
    const retailerID = accounts[4]
    const consumerID = accounts[5]
    const emptyAddress = '0x0000000000000000000000000000000000000000'
    let tx;

    ///Available Accounts
    ///==================
    ///(0) 0x27d8d15cbc94527cadf5ec14b69519ae23288b95
    ///(1) 0x018c2dabef4904ecbd7118350a0c54dbeae3549a
    ///(2) 0xce5144391b4ab80668965f2cc4f2cc102380ef0a
    ///(3) 0x460c31107dd048e34971e57da2f99f659add4f02
    ///(4) 0xd37b7b8c62be2fdde8daa9816483aebdbd356088
    ///(5) 0x27f184bdc0e7a931b507ddd689d76dba10514bcb
    ///(6) 0xfe0df793060c49edca5ac9c104dd8e3375349978
    ///(7) 0xbd58a85c96cc6727859d853086fe8560bc137632
    ///(8) 0xe07b5ee5f738b2f87f88b99aac9c64ff1e0c7917
    ///(9) 0xbd3ff2e3aded055244d66544c9c059fa0851da44

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Producer: accounts[1] ", accounts[1])
    console.log("Distributor: accounts[2] ", accounts[2])
    console.log("Retailer: accounts[3] ", accounts[3])
    console.log("Consumer: accounts[4] ", accounts[4])
    console.log("Certifier: accounts[5] ", accounts[5])
    console.log("Extra account: accounts[6] ", accounts[6])

    it("Testing add role", async function() { 
        const supplyChain = await SupplyChain.deployed()
        await supplyChain.addProducer(originProducerID, {from: ownerID})
        await supplyChain.addCertifier(certifierID, {from: ownerID})
        await supplyChain.addDistributor(distributorID, {from: originProducerID})
        await supplyChain.addRetailer(retailerID, {from: distributorID})
        await supplyChain.addConsumer(consumerID, {from: retailerID})
        assert.isTrue(await supplyChain.isProducer(originProducerID));
        assert.isTrue(await supplyChain.isCertifier(certifierID));
        assert.isTrue(await supplyChain.isDistributor(distributorID));
        assert.isTrue(await supplyChain.isRetailer(retailerID));
        assert.isTrue(await supplyChain.isConsumer(consumerID));
    })

    it("Testing add role without permission", async function() { 
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.addProducer(accounts[6], {from: distributorID}));
        await expectThrow(supplyChain.addProducer(accounts[6], {from: retailerID}));
        await expectThrow(supplyChain.addProducer(accounts[6], {from: consumerID}));
        await expectThrow(supplyChain.addProducer(accounts[6], {from: certifierID}));
        await expectThrow(supplyChain.addDistributor(accounts[6], {from: retailerID}));
        await expectThrow(supplyChain.addDistributor(accounts[6], {from: consumerID}));
        await expectThrow(supplyChain.addDistributor(accounts[6], {from: distributorID}));
        await expectThrow(supplyChain.addRetailer(accounts[6], {from: consumerID}));
        await expectThrow(supplyChain.addRetailer(accounts[6], {from: retailerID}));
    })

    it("Testing renounce role", async function() { 
        const supplyChain = await SupplyChain.deployed()
        await supplyChain.addProducer(accounts[6], {from: ownerID});
        assert.isTrue(await supplyChain.isProducer(accounts[6]));
        await supplyChain.renounceProducer({from: accounts[6]});
        assert.isFalse(await supplyChain.isProducer(accounts[6]));

        await supplyChain.addDistributor(accounts[6], {from: ownerID});
        assert.isTrue(await supplyChain.isDistributor(accounts[6]));
        await supplyChain.renounceDistributor({from: accounts[6]});
        assert.isFalse(await supplyChain.isDistributor(accounts[6]));

        await supplyChain.addRetailer(accounts[6], {from: ownerID});
        assert.isTrue(await supplyChain.isRetailer(accounts[6]));
        await supplyChain.renounceRetailer({from: accounts[6]});
        assert.isFalse(await supplyChain.isRetailer(accounts[6]));

        await supplyChain.addConsumer(accounts[6], {from: ownerID});
        assert.isTrue(await supplyChain.isConsumer(accounts[6]));
        await supplyChain.renounceConsumer({from: accounts[6]});
        assert.isFalse(await supplyChain.isConsumer(accounts[6]));

        await supplyChain.addCertifier(accounts[6], {from: ownerID});
        assert.isTrue(await supplyChain.isCertifier(accounts[6]));
        await supplyChain.renounceCertifier({from: accounts[6]});
        assert.isFalse(await supplyChain.isCertifier(accounts[6]));
    })

    it("Testing smart contract function harvestGrapes() fails when sender is not a producer", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.harvestGrapes(upc, originProducerName, originProducerInformation, 
            originFarmLatitude, originFarmLongitude, 
            grapeType, harvestDate, harvestNotes, 
            {from: distributorID}
        ))
        await expectThrow(supplyChain.harvestGrapes(upc, originProducerName, originProducerInformation, 
            originFarmLatitude, originFarmLongitude, 
            grapeType, harvestDate, harvestNotes, 
            {from: retailerID}
        ))
        await expectThrow(supplyChain.harvestGrapes(upc, originProducerName, originProducerInformation, 
            originFarmLatitude, originFarmLongitude, 
            grapeType, harvestDate, harvestNotes, 
            {from: consumerID}
        ))
        await expectThrow(supplyChain.harvestGrapes(upc, originProducerName, originProducerInformation, 
            originFarmLatitude, originFarmLongitude, 
            grapeType, harvestDate, harvestNotes, 
            {from: certifierID}
        ))
    })

    it("Testing smart contract function harvestGrapes() that allows a producer to harvest grapes", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as GrapesHarvested by calling function harvestGrapes()
        tx = await supplyChain.harvestGrapes(
            upc, 
            originProducerName, 
            originProducerInformation, 
            originFarmLatitude, 
            originFarmLongitude, 
            grapeType, 
            harvestDate, 
            harvestNotes, 
            {from: originProducerID}
        )

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 0, 'Error: Invalid item State')
        assert.equal(resultBufferOne[4], originProducerID, 'Error: Missing or Invalid originProducerID')
        assert.equal(resultBufferOne[5], originProducerName, 'Error: Missing or Invalid originProducerName')
        assert.equal(resultBufferOne[6], originProducerInformation, 'Error: Missing or Invalid originProducerInformation')
        assert.equal(resultBufferOne[7], originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude')
        assert.equal(resultBufferOne[8], originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude')
        assert.equal(resultBufferOne[9], grapeType, 'Error: Invalid grapeType')
        assert.equal(resultBufferTwo[1], harvestDate, 'Error: Invalid harvestDate')
        assert.equal(resultBufferTwo[2], harvestNotes, 'Error: Invalid harvestNotes')
        assert.equal(tx.logs[0].event, 'GrapesHarvested');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.grapeType, grapeType);
        assert.equal(tx.logs[0].args.harvestDate, harvestDate);
    })    

    it("Testing smart contract function harvestGrapes() fails when UPC already exists", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.harvestGrapes(upc, originProducerName, originProducerInformation, 
            originFarmLatitude, originFarmLongitude, 
            grapeType, harvestDate, harvestNotes, 
            {from: originProducerID}
        ))
    })

    it("Testing smart contract function produceWine() is not possible before the grapes are processed", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.produceWine(upc, wineLotID, fermentationTankID, {from: originProducerID}))
    })

    it("Testing smart contract function ageWine() is not possible before the wine is produced", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.ageWine(upc, barrelID, numDaysAging, {from: originProducerID}))
    })

    it("Testing smart contract function bottleUpWine() is not possible before the wine is aged", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.bottleUpWine(upc, bottlingDate, numBottlesLot, {from: originProducerID}))
    })

    it("Testing smart contract function restWine() is not possible before the wine is bottled", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.restWine(upc, numDaysResting, {from: originProducerID}))
    })

    it("Testing smart contract function labelWine() is not possible before the wine is rested", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.labelWine(upc, wineLabel, wineInformation, {from: originProducerID}))
    })

    it("Testing smart contract function packWine() is not possible before the wine is labeled", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.packWine(upc, {from: originProducerID}))
    })

    it("Testing smart contract function sellWine() is not possible before the wine is packed", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.sellWine(upc, price, {from: originProducerID}))
    })

    it("Testing smart contract function buyWine() is not possible before the wine is for sale", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.buyWine(upc, {from: distributorID}))
    })

    it("Testing smart contract function shipWine() is not possible before the wine is sold", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.shipWine(upc, {from: distributorID}))
    })

    it("Testing smart contract function receiveWine() is not possible before the wine is shipped", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.receiveWine(upc, {from: retailerID}))
    })

    it("Testing smart contract function purchaseWine() is not possible before the wine is received", async() => {
        const supplyChain = await SupplyChain.deployed()
        await expectThrow(supplyChain.purchaseWine(upc, {from: consumerID}))
    })

    it("Testing smart contract function processGrapes() that allows a producer to process grapes", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Mark an item as GrapesProcessed by calling function processGrapes()
        tx = await supplyChain.processGrapes(upc, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 1, 'Error: Invalid item State')
        assert.equal(tx.logs[0].event, 'GrapesProcessed');
        assert.equal(tx.logs[0].args.upc, upc);
    })    

    it("Testing smart contract function produceWine() that allows a producer to produce wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineProduced by calling function produceWine()
        tx = await supplyChain.produceWine(upc, wineLotID, fermentationTankID, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 2, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[3], wineLotID, 'Error: Invalid wineLotID')
        assert.equal(resultBufferTwo[4], fermentationTankID, 'Error: Invalid fermentationTankID')
        assert.equal(tx.logs[0].event, 'WineProduced');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.wineLotID, wineLotID);
        assert.equal(tx.logs[0].args.fermentationTankID, fermentationTankID);
    })    

    it("Testing smart contract function ageWine() that allows a producer to age wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineAged by calling function ageWine()
        tx = await supplyChain.ageWine(upc, barrelID, numDaysAging, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 3, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[5], barrelID, 'Error: Invalid barrelID')
        assert.equal(resultBufferTwo[6], numDaysAging, 'Error: Invalid numDaysAging')
        assert.equal(tx.logs[0].event, 'WineAged');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.barrelID, barrelID);
        assert.equal(tx.logs[0].args.numDaysAging, numDaysAging);
    })    

    it("Testing smart contract function bottleUpWine() that allows a producer to bottle up wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineBottled by calling function bottleUpWine()
        tx = await supplyChain.bottleUpWine(upc, bottlingDate, numBottlesLot, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 4, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[7], bottlingDate, 'Error: Invalid bottlingDate')
        assert.equal(resultBufferTwo[8], numBottlesLot, 'Error: Invalid numBottlesLot')
        assert.equal(tx.logs[0].event, 'WineBottled');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.bottlingDate, bottlingDate);
        assert.equal(tx.logs[0].args.numBottlesLot, numBottlesLot);
    })    

    it("Testing smart contract function restWine() that allows a producer to rest wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineRested by calling function restWine()
        tx = await supplyChain.restWine(upc, numDaysResting, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 5, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[9], numDaysResting, 'Error: Invalid numDaysResting')
        assert.equal(tx.logs[0].event, 'WineRested');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.numDaysResting, numDaysResting);
    })    

    it("Testing smart contract function labelWine() that allows a producer to label wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Certifies producer first
        await supplyChain.certifyProducer(originProducerID, wineLabel, certification, {from: certifierID})
        // Mark an item as WineLabeled by calling function labelWine()
        tx = await supplyChain.labelWine(upc, wineLabel, wineInformation, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 6, 'Error: Invalid item State')
        assert.equal(resultBufferThree[1], wineLabel, 'Error: Invalid wineLabel')
        assert.equal(resultBufferThree[2], wineInformation, 'Error: Invalid wineInformation')
        assert.equal(resultBufferThree[3], certification, 'Error: Invalid certification')
        assert.equal(resultBufferThree[4], certifierID, 'Error: Invalid certifierID')
        assert.equal(tx.logs[0].event, 'WineLabeled');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.wineLabel, wineLabel);
        assert.equal(tx.logs[0].args.certification, certification);
    })    

    it("Testing smart contract function packWine() that allows a producer to pack wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WinePacked by calling function packWine()
        tx = await supplyChain.packWine(upc, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
    
        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 7, 'Error: Invalid item State')
        assert.equal(tx.logs[0].event, 'WinePacked');
        assert.equal(tx.logs[0].args.upc, upc);
    })    

    it("Testing smart contract function sellWine() that allows a producer to sell wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineForSale by calling function sellWine()
        tx = await supplyChain.sellWine(upc, price, imageHash, {from: originProducerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originProducerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 8, 'Error: Invalid item State')
        assert.equal(resultBufferThree[5], price, 'Error: Invalid price')
        assert.equal(resultBufferThree[6], imageHash, 'Error: Invalid imageHash')
        assert.equal(tx.logs[0].event, 'WineForSale');
        assert.equal(tx.logs[0].args.upc, upc);
        assert.equal(tx.logs[0].args.price, price);
    })    

    it("Testing smart contract function buyWine() fails when sender is not a distributor", async() => {
        const supplyChain = await SupplyChain.deployed()
        let amount = 6000000
        await expectThrow(supplyChain.buyWine(upc, {from: originProducerID, value: amount}));
        await expectThrow(supplyChain.buyWine(upc, {from: retailerID, value: amount}));
        await expectThrow(supplyChain.buyWine(upc, {from: consumerID, value: amount}));
        await expectThrow(supplyChain.buyWine(upc, {from: certifierID, value: amount}));
    })

    it("Testing smart contract function buyWine() without enough funds", async() => {
        const supplyChain = await SupplyChain.deployed()
        let amount = 4000000

        await expectThrow(supplyChain.buyWine(upc, {from: distributorID, value: amount}));

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne[3], 8, 'Error: Invalid item State')
    })    

    it("Testing smart contract function buyWine() that allows a distributor to buy wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        let amount = 6000000
        let change = 1000000
        let balanceBefore = await web3.eth.getBalance(distributorID);
        // Mark an item as WineSold by calling function buyWine()
        tx = await supplyChain.buyWine(upc, {from: distributorID, value: amount})
        //console.log(tx);
        let balanceAfter = await web3.eth.getBalance(distributorID);
        let txData = await web3.eth.getTransaction(tx.tx);
        //console.log(txData);
        const receipt = await web3.eth.getTransactionReceipt(tx.tx);
        let gasPrice = new BigNumber(txData.gasPrice);
        let gasUsed = new BigNumber(receipt.gasUsed);
        const gasCost = gasPrice.multipliedBy(gasUsed);        
        assert.equal(balanceBefore, (BigNumber(balanceAfter)).plus(gasCost).plus(BigNumber(amount)).minus(BigNumber(change)).toNumber());

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], distributorID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 9, 'Error: Invalid item State')
        assert.equal(resultBufferThree[5], price, 'Error: Invalid price')
        assert.equal(resultBufferThree[7], distributorID, 'Error: Invalid distributorID')
        assert.equal(tx.logs[0].event, 'WineSold');
        assert.equal(tx.logs[0].args.upc, upc);
    })    

    it("Testing smart contract function shipWine() that allows a distributor to ship wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineShipped by calling function shipWine()
        tx = await supplyChain.shipWine(upc, {from: distributorID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], distributorID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 10, 'Error: Invalid item State')
        assert.equal(resultBufferThree[7], distributorID, 'Error: Invalid distributorID')
        assert.equal(tx.logs[0].event, 'WineShipped');
        assert.equal(tx.logs[0].args.upc, upc);
    })    

    it("Testing smart contract function receiveWine() fails when sender is not a retailer", async() => {
        const supplyChain = await SupplyChain.deployed()
        let amount = 6000000
        await expectThrow(supplyChain.receiveWine(upc, {from: originProducerID}));
        await expectThrow(supplyChain.receiveWine(upc, {from: distributorID}));
        await expectThrow(supplyChain.receiveWine(upc, {from: consumerID}));
        await expectThrow(supplyChain.receiveWine(upc, {from: certifierID}));
    })

    it("Testing smart contract function receiveWine() that allows a retailer to mark wine received", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WineReceived by calling function receiveWine()
        tx = await supplyChain.receiveWine(upc, {from: retailerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], retailerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 11, 'Error: Invalid item State')
        assert.equal(resultBufferThree[8], retailerID, 'Error: Invalid retailerID')
        assert.equal(tx.logs[0].event, 'WineReceived');
        assert.equal(tx.logs[0].args.upc, upc);
    })    

    it("Testing smart contract function purchaseWine() fails when sender is not a consumer", async() => {
        const supplyChain = await SupplyChain.deployed()
        let amount = 6000000
        await expectThrow(supplyChain.purchaseWine(upc, {from: originProducerID}));
        await expectThrow(supplyChain.purchaseWine(upc, {from: distributorID}));
        await expectThrow(supplyChain.purchaseWine(upc, {from: retailerID}));
        await expectThrow(supplyChain.purchaseWine(upc, {from: certifierID}));
    })

    it("Testing smart contract function purchaseWine() that allows a consumer to purchase wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Mark an item as WinePurchased by calling function purchaseWine()
        tx = await supplyChain.purchaseWine(upc, {from: consumerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)        

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], consumerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], 12, 'Error: Invalid item State')
        assert.equal(resultBufferThree[9], consumerID, 'Error: Invalid consumerID')
        assert.equal(tx.logs[0].event, 'WinePurchased');
        assert.equal(tx.logs[0].args.upc, upc);
    })    

    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        
        // Verify the result set:
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], consumerID, 'Error: Missing or Invalid ownerID')        
        assert.equal(resultBufferOne[3], 12, 'Error: Missing or Invalid itemState')
        assert.equal(resultBufferOne[4], originProducerID, 'Error: Missing or Invalid originProducerID')        
        assert.equal(resultBufferOne[5], originProducerName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferOne[6], originProducerInformation, 'Error: Missing or Invalid originFarmInformation')
        assert.equal(resultBufferOne[7], originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude')
        assert.equal(resultBufferOne[8], originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude')
        assert.equal(resultBufferOne[9], grapeType, 'Error: Invalid grapeType')
    })

    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)
        
        // Verify the result set:
        assert.equal(resultBufferTwo[0], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferTwo[1], harvestDate, 'Error: Missing or Invalid harvestDate')
        assert.equal(resultBufferTwo[2], harvestNotes, 'Error: Missing or Invalid harvestNotes')
        assert.equal(resultBufferTwo[3], wineLotID, 'Error: Missing or Invalid wineLotID')
        assert.equal(resultBufferTwo[4], fermentationTankID, 'Error: Missing or Invalid fermentationTankID')
        assert.equal(resultBufferTwo[5], barrelID, 'Error: Missing or Invalid barrelID')
        assert.equal(resultBufferTwo[6], numDaysAging, 'Error: Missing or Invalid numDaysAging')
        assert.equal(resultBufferTwo[7], bottlingDate, 'Error: Missing or Invalid bottlingDate')
        assert.equal(resultBufferTwo[8], numBottlesLot, 'Error: Missing or Invalid numBottlesLot')
        assert.equal(resultBufferTwo[9], numDaysResting, 'Error: Missing or Invalid numDaysResting')
    })

    it("Testing smart contract function fetchItemBufferThree() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc)
               
        // Verify the result set:
        assert.equal(resultBufferThree[0], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferThree[1], wineLabel, 'Error: Missing or Invalid wineLabel')
        assert.equal(resultBufferThree[2], wineInformation, 'Error: Missing or Invalid wineInformation')
        assert.equal(resultBufferThree[3], certification, 'Error: Missing or Invalid certification')
        assert.equal(resultBufferThree[4], certifierID, 'Error: Missing or Invalid certifierID')
        assert.equal(resultBufferThree[5], price, 'Error: Missing or Invalid price')
        assert.equal(resultBufferThree[6], imageHash, 'Error: Missing or Invalid imageHash')
        assert.equal(resultBufferThree[7], distributorID, 'Error: Missing or Invalid distributorID')
        assert.equal(resultBufferThree[8], retailerID, 'Error: Missing or Invalid retailerID')
        assert.equal(resultBufferThree[9], consumerID, 'Error: Missing or Invalid consumerID')
    })

});


let expectThrow = async function(promise) {
    try {
        await promise;
    } catch(error) {
        assert.exists(error);
        return;
    }
    assert.fail("Expected an error but didn't see one");
}

